<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;一、问题：&quot;&gt;&lt;a href=&quot;#一、问题：&quot; class=&quot;headerlink&quot; title=&quot;一、问题：&quot;&gt;&lt;/a&gt;一、问题：&lt;/h3&gt;&lt;p&gt;ELK日志系统延时严重，redis经常是内存使用率100%"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>ELK日志系统性能优化 | linkpwd|</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">主页</a><a class="sidebar-nav-item" href="/archives">归档</a></nav><div class="container post-meta"><div class="post-time">2021-12-14</div></div></div><div class="container post-header"><h1>ELK日志系统性能优化</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">一、问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">二、分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">三、解决：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E5%AE%83%E7%9B%B8%E5%BA%94%E9%85%8D%E7%BD%AE%E5%8F%AF%E9%80%89%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">四、其它相应配置可选：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">五、参考资料：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">1. 性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%85%B3%E4%BA%8E%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%9Alogstash-filter"><span class="toc-number">5.2.</span> <span class="toc-text">2、关于收集日志的选择：logstash&#x2F;filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81logstash%E7%9A%84%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-number">5.3.</span> <span class="toc-text">3、logstash的优化相关配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%95%E5%85%A5Redis%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">4、引入Redis的相关问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Elasticsearch%E8%8A%82%E7%82%B9%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">5.5.</span> <span class="toc-text">5、Elasticsearch节点优化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%80%A7%E8%83%BD%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="toc-number">5.6.</span> <span class="toc-text">6、性能的检查</span></a></li></ol></li></ol></details></div><div class="container post-content"><h3 id="一、问题："><a href="#一、问题：" class="headerlink" title="一、问题："></a>一、问题：</h3><p>ELK日志系统延时严重，redis经常是内存使用率100%</p>
<h3 id="二、分析："><a href="#二、分析：" class="headerlink" title="二、分析："></a>二、分析：</h3><p>整套ELK系统肯定是经受得住考验的。整体架构： filebeat –&gt; redis –&gt; logstash –&gt; es –&gt; kibana</p>
<p>之前对elasticsearch启动内存调优过，及其它各部件都进行了调整，最终发现应该是logstash吞吐率问题</p>
<h3 id="三、解决："><a href="#三、解决：" class="headerlink" title="三、解决："></a>三、解决：</h3><p>将如下参数通过环境变量的方式注入到k8s集群中，如其它参数需要优化，可新增</p>
<p>pipeline.workers: 4</p>
<p>pipeline.batch.size: 3000</p>
<h3 id="四、其它相应配置可选："><a href="#四、其它相应配置可选：" class="headerlink" title="四、其它相应配置可选："></a>四、其它相应配置可选：</h3><p>logstash.yml配置文件的相关参数:</p>
<p>pipeline.workers: 4 #一般配置为cpu核数，根据服务器实际情况 </p>
<p>pipeline.output.workers: 4 </p>
<p>pipeline.batch.size: 10000 </p>
<p>pipeline.batch.delay: 10</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/logstash-settin">logstash.yml配置文件</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/linkpwd/img/blob/99ff6481119fb308d3d8cafa78b6ff04611df5d3/2021-12-14-elk-001.png">elk</a></p>
<h3 id="五、参考资料："><a href="#五、参考资料：" class="headerlink" title="五、参考资料："></a>五、参考资料：</h3><h4 id="1-性能分析"><a href="#1-性能分析" class="headerlink" title="1. 性能分析"></a>1. 性能分析</h4><p>服务器硬件Linux：1cpu4GRAM<br>假设每条日志250Byte。<br>分析：</p>
<p>①logstash-Linux：1cpu 4GRAM</p>
<p>每秒500条日志；<br>去掉ruby每秒660条日志；<br>去掉grok后每秒1000条数据。<br>②filebeat-Linux：1cpu 4GRAM</p>
<p>每秒2500-3500条数据；<br>每天每台机器可处理：<br>24h<em>60min</em>60sec* 3000*250Byte=64,800,000,000Bytes，约64G。<br>③瓶颈在logstash从Redis中取数据存入ES，开启一个logstash，每秒约处理6000条数据；开启两个logstash，每秒约处理10000条数据（cpu已基本跑满）；</p>
<p>④logstash的启动过程占用大量系统资源，因为脚本中要检查java、ruby以及其他环境变量，启动后资源占用会恢复到正常状态。</p>
<h4 id="2、关于收集日志的选择：logstash-filter"><a href="#2、关于收集日志的选择：logstash-filter" class="headerlink" title="2、关于收集日志的选择：logstash/filter"></a>2、关于收集日志的选择：logstash/filter</h4><p>没有原则要求使用filebeat或logstash，两者作为shipper的功能是一样的。区别在于：</p>
<p>logstash由于集成了众多插件，如grok、ruby，所以相比beat是重量级的；<br>logstash启动后占用资源更多，如果硬件资源足够则无需考虑二者差异；<br>logstash基于JVM，支持跨平台；而beat使用golang编写，AIX不支持；<br>AIX 64bit平台上需要安装jdk（jre） 1.7 32bit，64bit的不支持；<br>filebeat可以直接输入到ES，但是系统中存在logstash直接输入到ES的情况，这将造成不同的索引类型造成检索复杂，最好统一输入到els 的源。<br>总结：logstash/filter总之各有千秋，但是我推荐选择：在每个需要收集的日志服务器上配置filebeat，因为轻量级，用于收集日志；再统一输出给logstash，做对日志的处理；最后统一由logstash输出给es。</p>
<h4 id="3、logstash的优化相关配置"><a href="#3、logstash的优化相关配置" class="headerlink" title="3、logstash的优化相关配置"></a>3、logstash的优化相关配置</h4><p>可以优化的参数，可根据自己的硬件进行优化配置：</p>
<p>①pipeline线程数，官方建议是等于CPU内核数</p>
<p>默认配置 —&gt; pipeline.workers: 2；<br>可优化为 —&gt; pipeline.workers: CPU内核数（或几倍CPU内核数）。<br>②实际output时的线程数</p>
<p>默认配置 —&gt; pipeline.output.workers: 1；<br>可优化为 —&gt; pipeline.output.workers: 不超过pipeline线程数。<br>③每次发送的事件数</p>
<p>默认配置 —&gt; pipeline.batch.size: 125；<br>可优化为 —&gt; pipeline.batch.size: 1000。<br>④发送延时</p>
<p>默认配置 —&gt; pipeline.batch.delay: 5；<br>可优化为 —&gt; pipeline.batch.size: 10。<br>总结：</p>
<p>通过设置-w参数指定pipeline worker数量，也可直接修改配置文件logstash.yml。这会提高filter和output的线程数，如果需要的话，将其设置为cpu核心数的几倍是安全的，线程在I/O上是空闲的。<br>默认每个输出在一个pipeline worker线程上活动，可以在输出output中设置workers设置，不要将该值设置大于pipeline worker数。<br>还可以设置输出的batch_size数，例如ES输出与batch size一致。<br>filter设置multiline后，pipline worker会自动将为1，如果使用filebeat，建议在beat中就使用multiline，如果使用logstash作为shipper，建议在input中设置multiline，不要在filter中设置multiline。<br>Logstash中的JVM配置文件：</p>
<p>Logstash是一个基于Java开发的程序，需要运行在JVM中，可以通过配置jvm.options来针对JVM进行设定。比如内存的最大最小、垃圾清理机制等等。JVM的内存分配不能太大不能太小，太大会拖慢操作系统。太小导致无法启动。默认如下：</p>
<p>Xms256m#最小使用内存；<br>Xmx1g#最大使用内存。</p>
<h4 id="4、引入Redis的相关问题"><a href="#4、引入Redis的相关问题" class="headerlink" title="4、引入Redis的相关问题"></a>4、引入Redis的相关问题</h4><p>filebeat可以直接输入到logstash（indexer），但logstash没有存储功能，如果需要重启需要先停所有连入的beat，再停logstash，造成运维麻烦；另外如果logstash发生异常则会丢失数据；引入Redis作为数据缓冲池，当logstash异常停止后可以从Redis的客户端看到数据缓存在Redis中；</p>
<p>Redis可以使用list(最长支持4,294,967,295条)或发布订阅存储模式；</p>
<p>Redis做ELK缓冲队列的优化：</p>
<p>bind 0.0.0.0 #不要监听本地端口；<br>requirepass ilinux.io #加密码，为了安全运行；<br>只做队列，没必要持久存储，把所有持久化功能关掉：<br>快照（RDB文件）和追加式文件（AOF文件），性能更好；<br>save “” 禁用快照；<br>appendonly no 关闭RDB。<br>把内存的淘汰策略关掉，把内存空间最大<br>maxmemory 0 #maxmemory为0的时候表示我们对Redis的内存使用没有限制。</p>
<h4 id="5、Elasticsearch节点优化配置"><a href="#5、Elasticsearch节点优化配置" class="headerlink" title="5、Elasticsearch节点优化配置"></a>5、Elasticsearch节点优化配置</h4><p>服务器硬件配置，OS参数：</p>
<p>1）/etc/sysctl.conf 配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf </span></span><br><span class="line">vm.swappiness = 1   <span class="comment">#ES 推荐将此参数设置为 1，大幅降低 swap 分区的大小，强制最大程度的使用内存，注意，这里不要设置为 0, 这会很可能会造成 OOM </span></span><br><span class="line">net.core.soma   xconn = 65535     <span class="comment">#定义了每个端口最大的监听队列的长度 </span></span><br><span class="line">vm.max_map_count= 262144    <span class="comment">#限制一个进程可以拥有的VMA(虚拟内存区域)的数量。虚拟内存区域是一个连续的虚拟地址空间区域。当VMA 的数量超过这个值，OOM </span></span><br><span class="line">fs.file-max = 518144    <span class="comment">#设置 Linux 内核分配的文件句柄的最大数量 </span></span><br><span class="line"><span class="comment"># sysctl -p    #生效一下 </span></span><br></pre></td></tr></table></figure>

<p>2）limits.conf 配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/security/limits.conf elasticsearch    </span></span><br><span class="line">soft    nofile          65535 </span><br><span class="line">elasticsearch    hard    nofile          65535 </span><br><span class="line">elasticsearch    soft    memlock         unlimited </span><br><span class="line">elasticsearch    hard    memlock         unlimited</span><br></pre></td></tr></table></figure>

<p>3）为了使以上参数永久生效，还要设置两个地方：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/common-session-noninteractive</span></span><br><span class="line"><span class="comment"># vim /etc/pam.d/common-session</span></span><br></pre></td></tr></table></figure>
<p>添加如下属性：<br>session required pam_limits.so<br>可能需重启后生效。</p>
<p>Elasticsearch中的JVM配置文件：</p>
<p>-Xms2g -Xmx2g<br>将最小堆大小（Xms）和最大堆大小（Xmx）设置为彼此相等。<br>Elasticsearch可用的堆越多，可用于缓存的内存就越多。但请注意，太多的堆可能会使您长时间垃圾收集暂停。<br>设置Xmx为不超过物理RAM的50％，以确保有足够的物理内存留给内核文件系统缓存。<br>不要设置Xmx为JVM用于压缩对象指针的临界值以上；确切的截止值有所不同，但接近32 GB。不要超过32G，如果空间大，多跑几个实例，不要让一个实例太大内存。<br>Elasticsearch配置文件优化参数<br>1）主配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim elasticsearch.yml bootstrap.memory_lock: true  #锁住内存，不使用swap #缓存、线程等优化如下 </span></span><br><span class="line">bootstrap.mlockall: <span class="literal">true</span> </span><br><span class="line">transport.tcp.compress: <span class="literal">true</span> </span><br><span class="line">indices.fielddata.cache.size: 40% </span><br><span class="line">indices.cache.filter.size: 30% </span><br><span class="line">indices.cache.filter.terms.size: 1024mb </span><br><span class="line">threadpool:     </span><br><span class="line">search:</span><br><span class="line"><span class="built_in">type</span>: cached</span><br><span class="line">size: 100         </span><br><span class="line">queue_size: 2000 </span><br></pre></td></tr></table></figure>

<p>2）设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile.d/elasticsearch.sh  </span></span><br><span class="line"><span class="built_in">export</span> ES_HE AP _SIZE=2g <span class="comment">#Heap Size不超过物理内存的一半，且小于32G。</span></span><br></pre></td></tr></table></figure>

<p>集群的优化（我未使用集群）：</p>
<p>ES是分布式存储，当设置同样的cluster.name后会自动发现并加入集群；<br>集群会自动选举一个master，当master宕机后重新选举；<br>为防止”脑裂”，集群中个数最好为奇数个；<br>为有效管理节点，可关闭广播discovery. zen.ping.multicast.enabled: false，并设置单播节点组discovery.zen.ping.unicast.hosts: [“ip1”, “ip2”, “ip3”]。</p>
<h4 id="6、性能的检查"><a href="#6、性能的检查" class="headerlink" title="6、性能的检查"></a>6、性能的检查</h4><p>检查输入和输出的性能：Logstash和其连接的服务运行速度一致，它可以和输入、输出的速度一样快。</p>
<p>检查系统参数：</p>
<p>1）CPU<br>注意CPU是否过载。在Linux/Unix系统中可以使用top-H查看进程参数以及总计。<br>如果CPU使用过高，直接跳到检查JVM堆的章节并检查Logstash worker设置。<br>2）Memory<br>注意Logstash是运行在Java虚拟机中的，所以它只会用到你分配给它的最大内存。<br>检查其他应用使用大量内存的情况，这将造成Logstash使用硬盘swap，这种情况会在应用占用内存超出物理内存范围时。<br>3）I/O监控磁盘I/O检查磁盘饱和度<br>使用Logstash plugin（例如使用文件输出）磁盘会发生饱和。<br>当发生大量错误，Logstash生成大量错误日志时磁盘也会发生饱和。<br>在Linux中，可使用iostat，dstat或者其他命令监控磁盘I/O。<br>4）监控网络I/O<br>当使用大量网络操作的input、output时，会导致网络饱和。<br>在Linux中可使用dstat或iftop监控网络情况。<br>检查JVM heap：</p>
<p>heap设置太小会导致CPU使用率过高，这是因为JVM的垃圾回收机制导致的。<br>一个快速检查该设置的方法是将heap设置为两倍大小然后检测性能改进。不要将heap设置超过物理内存大小，保留至少1G内存给操作系统和其他进程。<br>你可以使用类似jmap命令行或VisualVM更加精确的计算JVM heap。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>